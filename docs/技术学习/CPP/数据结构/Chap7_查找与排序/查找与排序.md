# 查找与排序

## 查找

-   查找
    -   在数据集合中, 寻找满足某种条件的数据元素的过程
-   查找表(查找结构)
    -   用于查找的数据集合
-   关键字
    -   数据元素中某个数据项的值, 用它可以标识一个数据元素
    -   主关键字
        -   关键字可以唯一地标识一个记录
            -   例如学生的学号
-   平均查找长度
    -   所有查找过程中进行关键字的比较次数的平均值
        -   ASL = P~1~C~1~+P~2~C~2~+……+P~n~C~n~
            -   p~i~表示第i个元素被查找到的概率
            -   C~i~表示第i个元素被查找的次数

### 顺序查找

-   基本思想
    -   从线性表的一端开始, 逐个检查关键字是否满足给定的条件. 若查找到某个元素的关键字满足条件, 则查找成功, 返回该元素在线性表中的位置. 若查找到表的另一端, 仍为找到符合给定条件的元素, 则返回查找失败的信息

-   对线性链表只能进行顺序查找

-   >   

    -   此例题找出规律, 求出第i个元素被查找的次数即可

### 折半查找

-   必须是**有序的顺序表**

>   

理解即可, 比较简单

>   

### 散列表	未理解

-   散列函数
    -   $Hash(key) = Addr$(地址)
-   同义词
    -   散列函数可能会把两个或两个以上的不同关键字映射到同一地址
        -   例如: 3%4 = 3		7%4 = 3		3和7是同义词
-   常见的散列函数
    -   直接定址法
        -   $H(key) = key		H(key) = a*key + b$
    -   除留余数法
        -   散列表表长为:m		去一个不大于但最接近或等于m的质数p	$H(key) = key%p$
    -   数字分析法
    -   平方取中法

-   解决同义词冲突的方法
    -   开放定址法
        -   可存放新表项的空闲地址既向它的同义词表项开放, 又向它的非同义词表项开放. 其数学递推公式为 $Hi = (H(key) + di) % m$
        -   di的求法
            -   线性探测法:    d~i~ = 0, 1, 2, …, m-1
            -   平方探测法:    d~i~ = 0^2^, 1^2^, -1^2^, 2^2^, -2^2^, …, k^2^, -k^2^      k<=m/2
            -   再散列法:        d~i~ = Hash~2~(key)

## 排序

-   ### 排序

    -   将一组杂乱无章的数据按一定规律顺序排列起来. 即, 将无序序列排成一个有序序列(由小到大或由大到小)的运算
    -   如果参加排序的数据结点包含多个数据域, 那么排序往往是针对其中某个域而言的

-   ### 排序方法的分类

-   #### 按存储介质

    -   内部排序
        -   数据量不大、数据在内存, 无需内外存交换数据
    -   外部排序
        -   数据量较大、数据在外存	(文件排序)
        -   外部排序时, 要将数据分批调入内存来排序, 中间结果还要及时放入外存, 显然外部排序要复杂很多

-   #### 按比较器个数

-   串行排序

    -   单处理机(同一时刻比较一对元素)

-   并行排序

    -   多处理机(同一时刻比较多对元素)

-   #### 按主要操作可分为

    -   比较排序

        ​	==插入排序、交换排序、选择排序、归并排序==

    -   基数排序

        -   不比较元素的大小, 仅仅根据元素本身的取值确定其有序位置

-   #### 按辅助空间

-   原地排序

    -   辅助空间用量为O(1)的排序方法
        -   所占的辅助存储空间与参加排序的数据量大小无关

-   非原地排序

    -   辅助空间用量超过O(1)的排序方法

-   #### 按稳定性

-   稳定排序

    -   能够使任何数值相等的元素, 排序以后相对次序不变

-   非稳定性排序

    -   不是稳定排序的方法

-   >   

-   ##### 稳定性的意义

    -   排序的稳定性只对**结构类型数据排序**有意义
    -   例如
        -   n个学生信息
            -   按照总分排序, 总分相同的情况下, 数学成绩高的排在前面

    -   排序方法是否稳定, 并不能作为衡量一个排序算法优劣的标准

-   #### 按自然性

-   自然排序

    -   输入数据越有序, 排序的速度越快的排序方法

-   非自然排序

    -   不是自然排序的方法

-   ### 插入排序

-   基本思想

    -   每一步将一个待排序的对象, 按其关键码大小, 插入到前面已经排好序的一组对象的适当位置上, 直到对象全部插入为止

    -   即边插入边排序, 保证子序列中损失都是排好序的

-   基本操作: 有序插入

    -   在有序序列中插入一个元素, 保持序列有序, 有序长度不断增加
    -   起初, a[0]是长度为1的子序列. 然后, 逐一将1[1]至a[n-1]插入到有序子序列中
    -   在插入a[i]前, 数组a的前半段(a[0]~a[i-1])是**有序段**, 后半段(a[i]~a[n-1])是停留于输入次序的**无序段**
    -   插入a[i]使a[0]~a[i-1]有序, 也就是**要为a[i]找到有序位置j**(0<=j<=i), 将a[i]插入在a[j]的位置上

>   

-   #### 直接插入排序

-   ##### 采用顺序查找法查找插入位置

-   >   

-   ##### 使用哨兵

-   >   

-   时间复杂度结论

    -   原始数据越接近有序, 排序速度越快
    -   最坏情况下(输入数据使逆有序的)
        -   Tw(n) = O(n^2^)
    -   平均情况下, 耗时差不多是最坏情况的一半
        -   Te(n) = O(n^2^)
    -   要提高查找速度
        -   减少元素的比较次数
            -   原有序列基本有序
        -   减少元素的移动次数
            -   原有序列记录的个数较少

-   #### 折半插入排序

-   >   

-   折半查找比顺序查找快, 所以折半插入排序就平均性能来说比直接插入排序要快

-   它所需要的关键码比较次数与待排序对象序列的初始排列无关, 仅依赖于对象个数. 在插入第i个对象时, 需要经过log~2~i+1次关键码比较, 才能确定它应插入的位置

    -   当n(待排序的值)较大时, 总关键码比较次数比直接插入排序的最坏情况要好得多, 但比其最好情况要差
    -   在排序对象的初始排序已经按关键码排好序或接近有序时, 直接插入排序比折半插入排序执行的关键码比较次数要少
    -   折半插入排序的对象移动次数与直接插入排序相同, 依赖于对象的初始排序
        -   减少了比较次数, 但没有减少移动次数
        -   平均性能优于直接插入排序
    -   时间复杂度:O(n^2^)
    -   空间复杂度:O(1)
    -   是一种**稳定**的排序方法

-   #### 希尔排序

-   基本思想

    -   先将整个待排记录序列分割成若干子序列, 分别进行直接插入排序, 待整个序列中的记录“基本有序”时, 再对全体记录进行一次直接插入排序
    -   思想的特点
        -   缩小增量
        -   多遍插入排序

>   

-   思路
    -   定义增量序列D~k~: D~M~>D~M-1~>D~M-2~>…>D~1~=1
        -   上面的例子中D~3~=5, D~2~=3, D~1~=1
    -   对每个D~k~进行“D~k~-间隔”插入排序(k = M, M-1, …, 1)
-   希尔排序的特点
    -   一次移动, 移动位置较大, 跳跃式地接近排序后的最终位置
    -   最后一次只需要少量移动
    -   增量序列必须是递减的, 最后一个必须是1
        -   因为最后一次是要执行全体的直接插入排序, 因此增量序列必须为1
    -   增增量序列应该是互质的
-   希尔排序是一种**不稳定**的排序算法
-   目前**尚未解决**如何选择最佳D序列
-   最后一个增量值必须为1, 无除了1之外的公因子
-   不宜在链式存储结构上实现