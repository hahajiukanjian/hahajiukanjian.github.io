# 绪论

#### **程序 = 数据结构 + 算法**

#### 数据 > 数据元素 > 数据项

> 学生表 > 个人记录 > 学号、姓名

#### 数据元素与数据对象

    **数据元素**——组成数据的基本单位

            与数据的关系：是集合的个体

    **数据对象**——性质相同的数据元素的集合

            与数据的关系：是集合的子集

### 数据结构的概念

    数据元素不是孤立存在的，他们之间存在着某种关系，数据元素互相之间的关系称为**结构**
    指**互相之间存在一种或多种特定关系**的数据元素的集合
    或者说，数据结构是**带结构的**数据元素的集合

### 数据结构包含的内容

-   **逻辑结构**

-   **存储结构** 

-   **运算和实现** 

#### 逻辑结构

- 线性结构
  一对一

- 非线性结构
  一对多

#### 存储结构

- 顺序存储结构 

- 链式存储结构

- 索引存储结构

    >   类似于通讯录

- 散列存储

### 数据类型和抽象数据类型

​	一些基本的数据结构可以由数据类型来实现

>   数组、字符串等

​	而另一些常用的数据结构，不能直接由数据类型来表示

>   栈、队列、树、图等

#### 数据类型

-   高级语言中的数据类型明显或隐含地规定了程序在执行期间变量的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。

    >   C语言中定义变量i位int类型，就表示i事[-max,max]范围的整数，在这个整数集上可以进行+、-、*、\、%等操作

-   数据类型是一组性质相同的值的集合以及定义在这个值的集合上的一组操作的总称

#### 抽象数据类型(ADT Abstract Data Type)

-   指一个数学模型以及定义在此数学模型上的一组操作。（不考虑计算机内的具体存储结构与运算的具体实现算法）

-   形式定义

    >   抽象数据类型可用(D、S、P)三元组表示
    >
    >   其中：D是数据对象;
    >
    >   ​		   S是D上的关系集
    >
    >   ​		   P是对D的基本操作集

    定义格式

    ```C
    ADT 抽象数据类型名
    {
        数据对象:<数据对象的定义>		//数据对象、数据关系的定义用伪代码描述
        数据关系:<数据关系的定义>
        基本操作:<基本操作的定义>		
    }ADT 抽象数据类型名
    ```

    基本操作定义格式：

    -   基本操作名(参数表)

        >   求圆的面积时：
        >
        >   area 	  (r)
        >   ^		    ^
        >   操作名   参数表

    -   初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足。则操作失败，并返回相应的出错信息。若初始条件为空，则忽略。

    -   操作结果：说明操作正常完成之后，数据结构的变化状况和应当返回的结果

>   **抽象数据类型圆形例子**
>
>   ```C
>   ADT Circle
>   {
>       数据对象: D={r,s,y|r,x,y均为实数}
>       数据关系: R={<r,x,y>|r是半径,<x,y>是圆心坐标}
>       基本操作:
>       	Circle(&C,r,x,y)
>               基本操作:构造一个圆。
>           double Area(C)
>                   初始条件:圆已存在。
>                   操作结果:计算面积。
>           double Circumference(C)
>                   初始条件:圆已存在。
>                   操作结果:计算周长。
>   	........
>   }ADT Circle
>   ```

#### 算法和算法分析

-   对特定问题求解方法和步骤的一种描述,它是**指令**的有限**序列**.其中每个指令表示一个或多个操作.

-   **算法的描述**

    -   自然语言描述

        >   算法,求一元二次方程的根:
        >
        >   1.   输入方程的系数a、b、c.
        >   2.   判断a是否等于零.如果等于,则提示不是一元二次方程.不等于零,则执行3.
        >   3.   计算d = b^2 - 4ac
        >   4.   判断d.如果d等于零……小于零……大于零……
        >   5.   结束

    -   流程图: 传统流程图、NS流程图

    -   伪代码: 类C语言

-   **算法与程序**

    -   **算法**是解决问题的一种方法或一个过程,考虑如何将输入转换成输出,一个问题可以由多种算法

    -   **程序**是用某种程序设计语言对算法的具体实现

        程序 = 数据结构 + 算法

-   **算法的特性**
    -   有穷性: 有穷步之后结束,每一步在有穷时间内结束
    -   确定性: 每一条指令必须有确切含义,没有二义性
    -   可行性:
    -   输入:     有零个或多个输入
    -   输出:     有一个或多个输出

-   **算法设计的要求**
    -   正确性: 使程序运行时,精心选择、典型、苛刻且带有刁难性的几组数据输入仍然能够得到满足的结果
    -   可读性
    -   健壮性: 输入非法数据是,算法能恰当的做出反应或进行相应处理,而不是产生莫名其妙的输出结果
    -   高效性: 少时间,少空间

##### **算法分析**

-   一个好的算法首先要具备正确性,健壮性,可读性,在几个方面都满足的情况下,主要考虑**算法的效率**,通过算法的效率高低来判断不同算法的优劣程度
-   时间效率和空间效率有时候是矛盾的 

-   ##### 时间效率

​			程序在计算机上执行所消耗的时间

​		事后统计

​				需要先将算法转换为程序.所得结果依赖于计算机的软硬件环境,可能掩盖住算法本身的优劣

​		**事前分析**

​				可以等于计算机执行一种简单的操作(赋值、移动、比较等)所需的时间与算法中进行的简单操作次数的**乘积**

​		**算法运行时间 = 每条语句执行的次数(语句频度) * 该语句执行一次所需的时间**

​			语句执行一次所需的时间:是由计算机软硬件决定的,与算法无关.一般假设为单位时间.因此**算法的运行时间**可以转化为**所有语句的执行次数**.即**语句频度之和**.

``` c
for(i=1; i<=n; i++)					//n+1
{
    for(i=1; i<=n; i++)				//n*(n+1)
    {
        printf("hello world");		//n*n
    }
}
```

上述代码块中的语句频度之和为: $2n^2 + 2n + 1$

由于每次都需要挨个语句的看太过麻烦,所以我们只需要比较它们的数量级即可.

>   $T(n) = 2n^3 + 3n^2 +2n +1$
>
>   n->∞时,$T(n)/n^3$ -> 2,这表示n充分大时,T(n)与n^3是同阶或同数量级,引入“O”记号
>
>   ​				**$T(n) = O(n^3)$**

基本操作的执行次数还随问题的输入数据集不同而不同

>   ```c
>   //顺序查找,在数组a[i]中查找值等于e的元素,返回其所在位置.
>   for(i=0; i<n; i++)
>       if(e == a[i])
>           return i+1;
>   return 0;
>   ```
>
>   上述代码	
>
>   ​				  最好情况:执行1次
>
>   ​			  	最坏情况:执行n次
>
>   平均时间复杂度为:O(n)
>
>   最坏时间复杂度为:n
>
>   最好时间复杂度为:1

##### 关于复杂算法的时间复杂度求法

​	对于复杂的算法,可以将它分成几个容易估算的部分,然后利用O的加法法则和乘法法则,计算算法的时间复杂度

​		**a)**加法法则

​			$T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))$

​		**b)**乘法法则

​			$T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))$

-   ##### 空间效率

    -   算法所需存储空间的度量

        >   $S(n) = O(f(n))$
        >
        >   ​	`n`为问题的规模

    -   算法要占据的空间

        -   算法本身要占据的空间,输入/输出,指令,常熟,变量等
        -   算法使用的**辅助空间**

>   将一位数组a中的n个数逆序存放到原数组中
>
>   ```C
>   for(i=0; i<n/2; i++)
>   {
>       t = a[i];
>       a[i] = a[n-i-1];
>       a[n-i-1] = t;
>   }
>   ```
>
>   此代码的空间复杂度为
>
>   ​			$S(n) = O(1)$
>
>   只需要一个变量t作为辅助空间来将数组逆序存储
>
>   ```C
>   for(i=0; i<n; i++)
>       b[i] = a[n-i-1];
>   for(i=0; i<n; i++)
>       a[i] = b[i];
>   ```
>
>   此代码的空间复杂度为
>
>   ​			$S(n) = O(n)$
>
>   需要一位数组作为辅助空间来将数组逆序存储

