# 分布式与集中式

## 集中式
集中式版本控制系统工具：CVS  SVN  收费：ClearCase

集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候使用的是自己的电脑。所以需要先从中央服务器获取最新的版本，才能开始干活。干完活后需要再把自己的活推送给中央服务器。
中央服务器就好比是图书馆，我们需要修改一本书的话，需要先从图书馆把书借出来，然后到家自己改，改完了再放回图书馆。

![图片](https://www.liaoxuefeng.com/files/attachments/918921540355872/l)

集中式版本控制系统最大的缺点就是必须联网才能工作。

## 分布式
分布式版本控制系统工具：git

分布式版本控制系统没有中央服务器，每个人的电脑上都是一个完整的版本库。这样我们在工作的时候可以不需要联网，因为版本库就在自己的电脑上。
> 既然版本在自己的电脑上，那么git是如何实现多人协同的呢？
> <br>
> 比如在自己的电脑上修改了文件A，同事在他的电脑上也修改了文件A。这时，我们俩之间只需要把各自的修改推送给对方，就可以看到对方的修改了。

与集中式相比，分布式的安全性要高很多，因为每个人的电脑里都有完整的版本库。
实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。
因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

![](https://www.liaoxuefeng.com/files/attachments/918921562236160/l)

## 一些举例说明 (可能并不正确)
> **集中式**好比是垄断行业，所有从业人员只是该行业的员工，本身不掌握生产资料，要参与生产必须从垄断寡头处暂时取得生产资料，自己保留的无效，不能作为生产资料投入生产
<br>
**分布式**类似于每个人都拥有支持生产的全套生产资料，随时都可以投入生产，生产内分工交换由分布式中的某些节点偶然充当
<br>
在程序版本控制方面使用分布式较优的原因是生产资料再生产的成本接近于0，相当于生产力无限大，如果程序版本在各节点的交换的困难程度大幅增加，分布式的优势就会减弱


> 集中式和分布式的区别是：
你的本地是否有完整的版本库历史！
假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。
假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息。你可以把本地的git库重新上传到另外的git服务商。


>Git 其实就是每个人电脑上都装一个svn服务器，你写了代码提交到自己电脑服务器上就是Commit；但是如果你想多人协作，就要把你的改动发送到你**每一个同事 **的svn服务器上就是push；
<br>
关于有人有疑问说
<br>
分布式的版本控系统如果要在多个人之间协作不也是需要一个像github一样的的远程版本库吗，这与集中式的有什么区别呢？
接着按照上面的理解，假如你还有10个同事，你每一次更改都要提交10次，其他同事有更改也要分别向我们提交，是不是觉得好烦，所以我们说干脆找一台固定电脑（服务器）用来统一规定把修改推给这台电脑，这样只需要提交1次就行了，其他人去这台机器上同步就好了。
<br>
发现没有，Git的中央服务器可以没有，我们只是为了方便才这么做的。
<br>
此时，如果这个中央服务器坏了，你只需要重新弄个电脑，把自己电脑上的同步一份过去，大家约定好都提交到这个新电脑上就行了。【所有的版本和历史都在，因为大家电脑上都是一样的】
<br>
而集中式的SVN就不同了，你从中央服务器上下载好完整的代码，正常工作（写代码）是可以，但是如果断网了，你就无法回滚版本；这时你可能谁说，先不提交，等联网了我再提交。
<br>
不好意思，这次断网是因为服务器报废了，是蒸发的那种，硬盘灰飞烟灭了。等你再次连上网的时候，就是你永远丢失了历史版本的时候，想回滚就只能靠做梦了。


# 安装git
- linux
根据linux的发行版本，使用不同的包管理器安装即可。

    - 以**arch**为例
        - `sudo pacman -S git`
- macOS
    - `brew install git`
- Windows
    - [git](https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496)
## 身份设置
```shell
git config --global user.name "Name"
git config --global user.email "email"
```
注意`git config`命令的`--global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。

# 工作区和暂存区

## 工作区
就是你在电脑访达/ranger里能看到的目录<br>
例如在zsh下执行ll(ls -l)命令
 ```shell
 GitTest on  main
➜ ls -l
total 8
-rw-r--r--  1 hahajiukanjian  staff  93  8 17 15:11 readme.txt
 ```
 
## 版本库
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。
Git的版本库里存了很多东西，其中最重要的就是`stage / index` 的暂存区，还有Git为我们创建的第一个分支`main / master`，以及指向`main / master`的一个指针`HEAD`。<br>
![工作区与暂存区示意图](https://www.liaoxuefeng.com/files/attachments/919020037470528/0)
分支与`HEAD`的概念在后面的章节。
<br>
前面我们把文件往Git版本库里添加时，分两步执行：
- 第一步`git add ...`把文件添加进去，实际上就是把文件与文件修改添加到暂存区。
- 第二步`git commit ...`提交更改，实际上就是把暂存区的所有内容提交到当前分支。
<br>

因为我们创建Git版本库时，Git自动为我们创建了唯一一个`main`分支，所以现在`git commit`就是往`main`分支上提交更改。

## 评论区的一些补充
> Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)<br>
工作区>>>>暂存区>>>>仓库<br>
git add把文件从工作区>>>>暂存区，git commit把文件从暂存区>>>>仓库，<br>
git diff查看工作区和暂存区差异，<br>
git diff --cached查看暂存区和仓库差异，<br>
git diff HEAD 查看工作区和仓库的差异，<br>
git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，<br>
git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。<br>

> git diff 时是分为两种情况的：暂存区为空和暂存区不为空。
> 首先我们明确知道git diff是比较工作区和暂存区的文件的，如果此时暂存区为空，那么稍微有点不同，即：
> 1 暂存区为空使用git diff：因为此时暂存区为空，此时使用git diff同样也是比较工作区和仓库，即和使用git diff HEAD结果相同
> 2 暂存区不为空使用git diff:因为此时暂存区不为空，此时使用git diff比较的就是工作区和暂存区









































